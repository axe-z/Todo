<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title><%= htmlWebpackPlugin.options.title %></title>
    <link rel="icon" type="image/png" href="favicon.png">
  </head>
  <body>
  <!-- <h1>React</h1> -->


<div id="MainInterface">

</div>

<div id="app"></div>
<div id="redux"></div>
<div class="notes">
<div class="section">
  <h1 class="center">Notes sur REACT / REDUX / KARMA / FIREBASE </h1>
   <h2>React..</h2>
  <li>A la base on a juste un render a lancer pour avoir du jsx a l ecran</li>
  <li>
React.createClass vs extends React.Component voir lien ici : :::::<a href="http://stackoverflow.com/documentation/reactjs/6371/react-createclass-vs-extends-react-component#t=201611112010580710903"></a></li>
<li>seulement un container doit etre retourné.</li>
<li> componentDidMount est une maniere d 'avoir acces au debut '</li>
<li>lui suggere de faire une variable avec nos props et les pointer vers this. props. valeur et dans le jsx utiliser que le nom de variable, ca fait du sens... </li>
<li>Les refs: permet de mettre un hook, pour acceder a un tag, et en tirer sa valeur par exemple. refs est un objet, et on accede a ses nom par dot notation</li>
<li>le state est l objet qui produit un refresh, doit etre creer d'avance, les props eux se font initialiser dans le render , sont read only, et mis sur le component terminé, le state est dans le corps du component et est read , write. BRef un component ne modifie pas ses props, mais modifie continuellement son state.</li>
<li>On les creer avec getInitialState en createClass, en es6, juste l object dans le constructor.</li>
<li>il est possible de faire des raccorci, puisque props est une onbjet let p = this.props , ensuite p.nom == this.props.nom</li>
<li>deux function sont importante ici a present.getInitialState et  getInitialState, function qui return un obj de key -> value</li>

</div>

<div class="section">
  <h2>Animer React avec Tweenmax</h2>
  <li>Dans componentDidMount, on doit selectionner le node ( le contenant unique du component)  node = ReactDOM findDOMNode (this) </li>
  <li>pour animer qu un seul des children, on doit le trouver ndas l index de children. et en faire une variable.</li>
  <li>Ensuite , meme chose qued habite avec GSAP</li>
</div>


<div class="section">
  <h2>Suite React, avoir plusieurs components</h2>
  <li>Quand et ou diviser ses components, ici la form devrait etre ailleurs, le greeting, l autre.</li>
  <li>il est suggere de faire une version statique bien divisee au depart et ensuite ajouter les fonctionnalites.</li>
  <li>Decider si prop ou state: simplement se demander si une valeur sera modifiee, si oui, STATE, sinon, props.</li>
</div>

<div class="section">
  <h2>Envoyer du data d'un component externe au container</h2>
  <li>Le container doit par exemple, sur un onchange, ou submit, appeler une function locale, cette fonction locale elle doit traiter le data une fois fait, doit la passer au container (on parle du component prinicipale) par un propriete, une prop.  </li>
  <li>dans l'externe on a ici par exemple une fonction onFormSubmit , cette fonction pour envoyer ca au container  a l'aide d une props function </li>
  <li>dans l'instance du component externe dans le container   nomducomponentexterne  on y met une props qui elle meme lance une function locale sur le contianer, qui change le state pour creer l ajustement , le rafraichissement.   </li>
</div>

<div class="section">
  <h2>Presention component VS container component</h2>
  <li>Un presentation component est un component sans state, il ne fait qu afficher ses props.</li>
  <li>un container compo. lui a ses state et va avoir les methodes qui s en suivent</li>
  <li>Si on contruit un objet pour les valeurs de state a changer, au lieu de faire des key value, on peut passer l object complet.</li>

</div>

<div class="section">
  <h2>division des components</h2>
  <li>Il devient plus facile de lire les fichieers une fois separe. faire un folder component, ensuite , importer react dans les fichiers du meme nom que les component</li>
  <li>des const doivent se faire exporter au debut sans default ou a la fin avec le default, et non pas au moment de sa creation avec default. default est un seul export par module</li>

</div>

<div class="section">
  <h2>Routing</h2>
  <li>le contenant est le Router, dans lui des routes , et les route sont logique a l ecran, dans le main,si on veut garder, mais aller a une autre page qui demande a ce que main reste, on fait le lien entre les deux bout de main et y mettre  /about. l autre props est component et appelle le nom du component que l on veut a ce path. </li>
  <li>IndexRoute, est pour celui par defaut si on veut, si le hash n'est pas juste, mettons que je tape abOt au lieu d about, ca ira a l index route. Compliquer, mais si on avait que des route, le / ne chargerait rien, mais la il a un children , dans l indexroute. Donc le indexroute devient le par defaut... avec indexroute s appelait defaultroute.. ce qui etait plus clair</li>
  <li>Link au lieu de a link, en majuscule le link, mais il est possible d'utiliser des a avec href de #/about , et ca fera le meme chemin. On utilise Link parce que nous avons la possibilite de stylyser specifiquement pour la page que l on veut.</li>
  <li>Aussi avec actviveClass, on peut determiner le defaut, et le style. </li>
  <li>Quand on utilise indexRoute, dans le router, sur le component en question, le lien du nav sera toujours actif avec Link, il faut utiliser indexLink</li>

</div>

<div class="section">
  <h2>Es6 promises</h2>
  <li>Voici un leger rappel sur les promesses</li>
  <pre><code>

     function addPromesse(a,b){
      return new Promise((res,rej) => {
        if ((typeof a === 'number') && (typeof b === 'number')) {
             res( a + b)  //ce que l on fait avec les deux var.
        } else {
          rej (' erreur')
        }
      }) ;
     }

     addPromesse(2,21).then(sum => {
       console.log(sum)
     }).catch(err => {
       console.log(err)
     })

     addPromesse(2,"b").then(sum => {
       console.log(sum)
     }).catch( err => {
       console.log('oups' + err )
     })
  </code></pre>
</div>

<div class="section">
  <h2>Linker tout..</h2>
  <li>La form onsubmit lance un func qui elle valide le data, et l envois a une func qui sera une props sur l elelment, qui elle meme lancera un handleSearch. elle recoit le data, et ici deviendra un state, et pour modifier, il faut des states.</li>
  <li>Ces state la pour les passer, on utilise la destrucration = le state, et le passe en props. le component qui recoit, peut lui aussi destructurer les state, mais rendu la , ils sont des props. Je me comprendrai jamais. </li>
  <pre><code>

  </code></pre>
</div>


<div class="section">
  <h2>Le fetch API</h2>
  <li>le point du fetch, c est qu il recoit du data, mais il sait pas quoi,  res.json()  est la cle et fait l object. </li>
  <li>ensuite on suit le chemin tout simplement vers ce que l on a de besoin.</li>
  <pre><code>


  return fetch(requestUrl)
  .then(function(res){
    return res.json()  //mets le blob en json
  }).then(res => {
    if(res.cod && res.message){
      throw new Error(res.message)
    } else {
    console.log(res)
   return Math.round(res.main.temp)   //patch d anl object.
  }}).catch(err => {
       console.log(err)    //si err.
    });
  }
getTemp('laval') retourne 22 ..

  </code></pre>
</div>


<div class="section">
  <h2>Retourner conditionnelement son jsx</h2>
  <li>il est possible de decider si on retourne ci ou ca, avec une function dans la portion render, avant le return. </li>
  <li>ca peut etre tel compoenent, ou celui la, il s agit seulement dnas le return entre parenthese jsx, de lancer la fu nction qui fait le if, et determine quoi montrer</li>
  <li></li>
</div>

<div class="section">
  <h2>Ajout des source-maps</h2>
  <li>Dans config de webpack   devtool: 'source-map' nous donne maintenant notre code dans la console et pas le code transformé, ca deveient bcp plus simple pour les erreurs.</li>

</div>

<div class="section">
  <h2>Stateless functionnal component</h2>
  <li>Qaund un component est plus simple, il est preferable d utiliser un SFC. </li>
  <li>on ne peut y mettre de refs, de methode de lifecycle non plus, snapppp. </li>
  <pre><code>

  </code></pre>
</div>

<div class="section">
  <h2>GIT</h2>
  <li>VOIR LES VIDEOS DANS THE COMPLETE REACT WEB APP COURSE VIDEO 40 A 45</li>
  <li>Pour installer git, dans le folder du project, taper git init dans le terminal , un fichier sera creer, qu on voit pas</li>
  <li>git status, permet de voir ou en est le git, et au depart aucun fichier n'est surveille, on ne veut seulement pas node-moudle</li>
  <li>.gitignore que l on doit creer au root, et y mettre ce qu'on ne veut pas tracker : .DS_Store , bs-config.json et node_modules/</li>
  <li>Si on relance git status, ceux ci ne sont plus present</li>
  <li>Maintenant pour faire un commit, on tape:  git add .gitignore pour ajouter a la liste verte se fichier.</li>
  <li>Maintenant pour eviter d avoir a tout taper, on peut seulement taper : GIT ADD .  avec le point, on ajoute tous les fichier non-black listé par le git ignore. refaire git status pour voir</li>
  <li>Tout est maintenant vert.Mais rien a raiment savé</li>
  <li>Maintenant pour sauvegarder : en minuscule: GIT COMMIT -m 'Commit Initial' , dans le string, on met simplement un description, si mose ajour , bug reparation, ou peu importe.</li>
  <li>la liste des fichiers sera a l ecran , refaire git status et la liste des fichier modifiers depuis y sera, icil index a changer parce que je tappe, et celui, le index fait par webpack aussi... </li>
  <li>Donc chaque fois qu on touche un fichier, il s ajoutera a la liste pas updatees rouge.</li>
  <li>on pourrait rfaire les memes etapes, mais : GIT COMMIT -A -M 'UPDATE' , ici j'ai eu a identifier l ordi.  </li>
  <li>Si un fichier est ajouté, on doit cependant l ajouter avec git add .</li>
   <li>j ai fait un readme, donc je doit refaire git add .</li>
  <br>  <br>  <br>

<h2>Dans Github</h2>
<li>compte axe-z, on doit dnas les settings alleer activer sa cle SSH, ce qui permet d associer les data et le compte.</li>
 <li>pour ne pas a avoir a taper, nom et password a chaque push, la cle est importante.</li>
 <li>pour se rendre a sa cle sur son ordi, dans le termianl tapper:  ls -al ~/.ssh</li>
 <li>id_rsa , est la cle privee.</li>
 <li>id_rsa.pub est la cle public pour le git hub.</li>
 <li>ajouter a son keychain d ordi, la cle git hub: une fois fait (voir videos) </li>
 <li>faire refresh sur git hub, et creer un repo</li>


 <h2>pousser le data la bas</h2>
 <li>git remote add origin https://github.com/axe-z/ReactStuff.git</li>
 <li>ensuite voir si ca fonctionne, y aura pas de confirmation : git remote -v</li>
 <li>edux lien arrivent , un fetch et un push</li>
 <li>origin  https://github.com/axe-z/ReactStuff.git (fetch)
origin  https://github.com/axe-z/ReactStuff.git (push)</li>
<li>git branch sit si on est sur le master</li>

<h3>une fois setter</h3>
<li>seulement faire un : git commit -a -m 'ajout copy'</li>
<li>une fois fait pour pusher au serveur: git push   et c'est fait</li>

</div>
  <br>  <br>  <br>  <br>  <br>  <br>
  <br>


  <div class="section">
    <h2>Comment ajouter un projet a git</h2>
    <li>arreter webpack</li>
    <li>lancer git init</li>
    <li>lancer git status, pour voir tous les fichier inclut (optionnel)</li>
    <li>lancer git add .</li>
    <li>lancer git commit -a -m 'Initial commit'</li>
    <li>Se rendre sur le site de github pour creer un nouveau repo</li>
    <li>A la page du quick setup, et on veut l option qui push du command line: on copy et paste : git remote add origin https://github.com/axe-z/nomdutruc.git
git push -u origin master</li>
     <li>Une fois fait, il s agit seulement de rafraichir la page et le repo devrait maintenant est rempli de mes fichiers.</li>
     <li>fin</li>
    <pre><code>

   partir le projet
     git init
     git status (optionel, montre les fichiers qui vont etre ajoutes)
     git add .
     git commit -a -m 'Initial commit'
     faire son repo, sur github, et copy pace les deux lignes
     git remote add origin https://github.com/axe-z/nomdutruc.git
     git push -u origin master

     the end.

      pour updater son projet
      dans l ordre :

      git status
      git add .     //si nouveau fichier
      git status
      git commit -am 'message'
      git push


      pour partir du boilerplate sur git,

      dans le terminal et etre sur le desktop, le vrai terminal aussi, hors projet,
      faire: git clone https://github.com/axe-z/boilerplateReact.git  (on va chercher le lien clone sur github )

     ca va faire un rep et amener les fichiers,

    </code></pre>
  </div>

  <div class="section">
    <h2>Pour etre sur d'etre deconnecte de git et heroku, si on reste dnas le meme folder, pour un autre projet.</h2>
    <li>Dans la console, on peut faire rm -rf ./.git/</li>
    <li>Sinon manuellement deleter le rep dans le tree du projet</li>
    <pre><code>
     pour deleter le git, quand on a fini et on veut en partir un autre
       rm -rf ./.git/

    </code></pre>
  </div>

<div class="section">
  <h2>Comment ajouter un projet heroku ( si compte ouvert )</h2>
  <li>Ca se fait dans le termianl sans avoir a aller sur le site de heroku</li>
  <li>D abord lancer heroku create</li>
  <li>pour verifier si ca fonctionne et qu il a ete chercher la bonne chose sur git:  git remote -v</li>
  <li>ensuite pour envoyer : git push heroku master</li>
  <li>il ne reste qu a lancer heroku (attendre 10 sec): heroku open</li>
  <pre><code>

  donc :
  heroku create
   git remote -v
  git push heroku master
  heroku open

  </code></pre>
</div>





<div class="section">
  <h2>Heroku pour la premiere fois</h2>
  <li>Une fois l installer fait, dans le terminal , lancer heroku</li>
  <li>pour savoir qui est loguer: heroku auth:whoami</li>
  <li>tout est installé.</li>
  <li>heroku doit lancer notre site/app, dela meme maniere que nous... avec un script dans npm..</li>
  <li>on doit faire un script qui s appele START, avec un port process.env.PORT , voir server.js</li>
  <li>heroku create , va creer une place pour l app</li>
  <li>de git a heroku : git push heroku master</li>
  <li>heroku open , va ouvrir le site</li>
  <li>fin</li>
  <pre><code>


pour updater son projet
dans l ordre :

git status
git add .     //si nouveau fichier
git status
git commit -am 'message'
git push
git push heroku master ///attendre 10 sec apres.
heroku open

  </code></pre>
</div>


<div class="section">
  <h2>Testing avec MJ</h2>
  <li>puisque react divise en plusieurs pieces, il devient difficile de savoir si un changement entraine pas des sequelles</li>
  <li>Donc il est imporetant d'incorporer du testing avec Mickeal Jacson expect .. oui oui</li>
  <li>https://github.com/mjackson/expect</li>
  <li>voici quelques exemples.. </li>
  <pre><code>
disont ...

function add (a,b){
 return a + b;
}
expect(add(2,2)).toEqual(4, 'sinon t as chier ca')
//ou
expect(add(2,2)).toBe(4, 'sinon t as chier ca')


 expect(2).toBeA('number')

 function capitaliser(mot){
  if(!mot || typeof mot !== 'string'){
    mot = ''
  }
   return _.capitalize(mot)
 }

 expect(capitaliser('benoit')).toBe('Benoit')
 expect(capitaliser('benoit')).toBeA('string')

    toExist

    expect(object).toExist([message])
    Asserts the given object is truthy.

    expect('something truthy').toExist()
    Aliases:

    toBeTruthy
    toNotExist

    expect(object).toNotExist([message])
    Asserts the given object is falsy.

    expect(null).toNotExist()
    Aliases:

    toBeFalsy
    toBe

    expect(object).toBe(value, [message])
    Asserts that object is strictly equal to value using ===.

    toNotBe

    expect(object).toNotBe(value, [message])
    Asserts that object is not strictly equal to value using ===.

    toEqual

    expect(object).toEqual(value, [message])
    Asserts that the given object equals value using is-equal.

    toNotEqual

    expect(object).toNotEqual(value, [message])
    Asserts that the given object is not equal to value using is-equal.

    suite sur le site
  </code></pre>
</div>

<div class="section">
  <h2>Unit testing avec Karma</h2>
  <li>installation: npm install karma@0.13.22 karma-chrome-launcher@0.2.2 karma-mocha@0.2.2 karma-mocha-reporter@2.0.0 karma-sourcemap-loader@0.3.7 karma-webpack@1.7.0 mocha@2.4.5 expect@1.14.0 --save-dev </li>
  <li>une fois fait, on doit faire un fichier karma.conf.js , et un rep tests, dans celui ci des fichiers , type genre nom.test.js</li>
  <li>importer expect, et faire un it('shouldbe a test', () 1 tobe 1 ..   )</li>
  <li>dans package.json, avoir un script qui lance karam start ...</li>
  <li>npm test  et non pas run test</li>
  <pre><code>
  app.test.js :
import expect


describe('App', () => {
  it('should properly run tests', () => {
    expect(1).toBe(1);
  })
})

  </code></pre>
</div>

<div class="section">
  <h2>installer un addons de react</h2>
  <li>npm install react-addons-test-utils --save-dev </li>
  <li>dans le rep tests, on fait un rep components, pour faire un mirroir de notre projet.</li>
  <li>En bas on regarde ce que ca l air</li>
  <li>utiliser mocha:</li>
  <pre><code>
importer
    React from "react";
    ReactDOM from "react-dom";
    expect from 'expect'
    { findDOMNode  } = ReactDOM;
    TestUtils from 'react-addons-test-utils';
    Clock from '../../js/components/Clock'   /// !!!! ON DOIT FAIRE LE PATH COMPLET.... !!!!


  // plus simple
   describe('Clock', () => {
     it('should existe', () => {
       expect(Clock).toExist()
     })

//utile maintenant
    describe('render', () => {
      it('devrait render clock to output', () => {
          let clock = TestUtils.renderIntoDocument(<Clock totalSecondes={62}/>); //appele le component
          let $el = $(findDOMNode(clock));  //on le selectionne avec  jquery
          var actualText = $el.find('.clock-text').text();  //on li le text, et bon ca devrait etre '01:02'

          expect(actualText).toBe('01:02')
      });
    })
  </code></pre>
</div>


<div class="section">
  <h2>Une fois pour tout REACT et comment passer le data</h2>
  <p>Dans le component child, celui qui sera ramener sur la parent, prennons une form child, qui ira sur le parent. Sur la forme il y aura un onSubmit, onChange, qui lancera une fonction justement, dans cette form, on rammasse la valeur des inputs, que l on met dans une variable. Dans cette function onsubmit, on va passer un that.props.nomDefunctionQuiSeraSurLeParent avec en parathese les variables des inputs, en fait le data.  en temps que props, sur l'element child il s'agit maintenant de faire un fonction HANDLE qui prend les variables fait sur le child, qui elle va changer un state, qu on aura fait avec getinitialstate sur le parent, disont compteur, qu on initialise a 0. Dans la function handle, on fera un setstate compteur: variableChild qu on a ramener de l autre fonction submit. Fin</p>
  <pre><code>

  </code></pre>
</div>


<div class="section">
  <h2>Lifecylcle pour declencher une action</h2>
  <li>componentDidUpdate permet de voir avec ses deux arguments, la props avanrt , et le state avant, et regarder si y a eu changement</li>
  <li>avec un if statement, on peut regarde si y a eu changement dans le state, si oui, le switch operateur, permet de faire quelque chose avec les different scenarios. </li>
  <li>il y a plein de chose qu on peuty vouloir faire, dans unMount , arreter les intervales, pour pas prendre de jus inutilement.</li>
  <pre><code>
    c omponentWillMount: function()
    c omponentDidMount: function()
    c omponentWillReceiveProps: function(nextProps)
    c omponentWillUpdate: function(nextProps, nextState)
    c omponentDidUpdate: function(prevProps, prevState)
    c omponentWillUnmount: function()
  </code></pre>
</div>

<div class="section">
  <h2>Petit rappel sur scss</h2>
  <li>il est suggere de nommer les fichier scss qui ne sont pas le principale _quelqueChose. scss </li>
  <li>Aussi dans l import, on ne met pas le _ et seulement le nom. END</li>
</div>


<div class="section">
  <h2>Comment dealer avec les lists de data, (array d'obj)</h2>
  <li>Bonne idee quand on fait une app, de se creer du fake data, dans getInitialState sur le main, qui peut donc se passer vers le  bas a tous les compo.</li>
  <li>quand on fait un map, filter, une iteration, sur un array, vers un component, il se doit d'y avoir un key, ici c'est simple, on a un id. Sinon map en donne un (index) anyway</li>
  <li>On peut passer tout le data down a vec le spread operator. ici le id et text. (de todolist a todo)</li>
  <pre><code>

  </code></pre>
</div>

<div class="section">
  <h2>Revue du Spread operator de ES6</h2>
  <li>il est possible d'appeler une function avec comme arguments, un array, un array spreader</li>
  <li>comment ajouter a notre arr todos, prendra cette recette</li>
  <pre><code>
voir code dans app.js
  </code></pre>
</div>

<div class="section">
  <h2>Comment ajouter ud data  a notre arr todos, </h2>
  <li>on doit spreader this.state.todos et non pas pas juste todos.. </li>
  <li>voir le code , et that 's it ! , on fait ca dans la function qui recoit le text.</li>
  <pre><code>
   set State({
      todos: [
        ...this.state.todos, ///ca donne ce qu on a deja avec le spread
        {                     // et on ajoute un objet de plus a l array d'obj !!!
          id: uuid(),      ///nous donne un id unique
          text: text       //le texte est rece de l unpit et passer a handl Add todo
        }
      ]
    })
  </code></pre>
</div>


<div class="section">
  <h2>Comment creer un id, toujours unique avec node-uuid</h2>
  <li>np  install node-uuid --save-dev . ET maintenant partout ou on veut un id , on met uuid ()</li>
  <li>sur la page qu on l utilise on doit METTRE : importe uuid de 'node-uuid' , on peut pas mettre de -</li>
  <li>Plus besoin de jamais y penser, le petit pluggin s assure de jamais repeter, y va avec le temps.</li>

</div>

<div class="section">
  <h2>Sauvegarder les donnees, sans base de donnee ( localstorage )</h2>
  <li>il est preferable de gerer ce qui est base de donnees sur un autre fichier, celle -ci n a pas vraiment avoir avec le fonctionnement directe de l app, et pourrait changer a tout temps.</li>
  <li>Donc dans le rep API, on fait le todoapi</li>
  <li>donc dans le inoitial state, au lieu d avoir le gros array, todos, va appeler Todo api . gettodos ()</li>
  <li>Maintenant pour sauvergarder les changements, quand il y en a, on utilise un des lifecycles, qui se lance a chaque update: componentDidUpdate et lancer todoapi . setTodos () enlui passant l arr de todos, pour savoir quoi regarder et sauvegarder.</li>
  <li>le probleme est que localstorage ne prend que des strings , il prend pas des arrays ....</li>
  <li>Donc on doit utiliser JSON.stringify (arr) pour transformer en string l array todos</li>
  <li>maintenant notre programme a besoin d un array, donc avec le string receuilli par getitem, et le stringg recu, il faut refaire un array.</li>
  <li>JSON.parse est la solution, maintenant, ca peut chier , si le data est pas bon. donc , mieux vaut le faire dans un try catch block, pour s assurer que tout ce passe bien et capter les erreures .</li>
  <li>Rappel : JSON.stringify, transforme un arr en string, JSON.parse, fait le contraire !</li>
  <pre><code>
  localstorage 3 mains methodes

  getItem
  setItem
  removeItem
  ls.setItem('plan1', 'chien');
  ls.getItem('plan1') === chien
  ls.removeItem('plan1')  === ''

  stringTodos avec 2 item ressemble a ca avant le parse : "[{"id":"b7401611-1b85-4f33-81c2-05dfa04417c9","text":"lavage du linge sale","completed":false},{"id":"71ac0b93-b624-4fa1-b1ba-946f2b914c80","text":"faire a souper","completed":false}]"



  </code></pre>
</div>
<div class="section">
  <h2>SORT filtrer par conditions</h2>
  <li>pour classer javascript, vient avec un fonction, qui permet, de classer en regardant tousles items de l array</li>
  <li>Donc c'est tjrs a VS b, si on veut que A soit AVANT B, on retourne -1 , si le contraire est voulu, on retour 1</li>
  <li>Si on ne veut pas de changement , on retourne 0</li>
  <pre><code>
    filteredTodos.sort((a,b) => {
    A soit AVANT B, on retourne -1
    B soit AVANT A, on retourne 1
    Si on ne veut pas de changement on retourne 0
    })

    ///a et b sont chaque instance de l arr  , et cca va bien avec un ternary ... lui le fait pas de meme
    filteredTodos sort((a,b) => {
        return !a.completed ? 1 : -1   // va faire en sorte que si pas completed ils vont etre a la fin.
    })
  </code></pre>
</div>


<div class="section">
  <h2>IndexOf, filter par mots</h2>
  <li>On couple indexof avec filter() et la condition de filter sera le indexof</li>
  <li>indexOf retourne le premier index qui match la condition, sinon retourne -1</li>
  <li>il est un bon principe, de mettre ce qu on recherche ET l array en tolowercase, comment ca moins de fuckup arrive.</li>
  <li></li>
  <pre><code>
   Avec 'something ici'.indexof('ici') est true
   filteredTodos = filteredTodos filter((todo) => {
    let todoText = todo text toLowerCase();
     return searchText length === 0 ||  todoText indexOf(searchText) > -1 ;  //va retourner rien d ecrit ||  et > -1 si oui

   })
  </code></pre>
</div>


<div class="section">
  <h2>Gere le temps Avec MOMENTS.JS</h2>
  <li>il est possible avec moment format de sortir un string de la date et heure avec fuseau horaire</li>
  <li>Il est aussi possible de s en tenir au epoc, et les timestamp</li>
  <li>lien pour les docs: <a href="https://momentjs.com">MOMENT.JS</a></li>
  <pre><code>
epoc
//// 1 jan 1970 a 12:00am === 0
//// 1 jan 1970 a 12:01am === 60
moment
avec format donne un string
//console.log(moment().format()) //2017-04-23T17:52:39-04:00

avec unix() ca donne le epoc, timestamp
console.log('Current', now.unix()) // Current 1492985033

//dans les notes
moment().format('MMMM Do YYYY, h:mm:ss a'); // avril 23e 2017, 6:10:22 pm
moment().format('dddd');                    // dimanche
moment().format("MMM Do YY");               // avr. 23e 17
moment().format('YYYY [escaped] YYYY');     // 2017 escaped 2017



//MOMENT.JS MOMENT.JS MOMENT.JS MOMENT.JS MOMENT.JS MOMENT.JS MOMENT.JS MOMENT.JS MOMENT.JS
//import moment from 'moment';
  console.log(moment().format()) //2017-04-23T17:52:39-04:00
  ///instance de moment;

 //IMPORT DE LA VERSION FRANCAISE, A GARDER. IMPORT DE LA VERSION FRANCAISE, A GARDER.
// import momentFr from './api/momentFr';   ////import de la version francaise, a garder.

 let now = moment()

 console.log('Current: ', now.unix()) //Current: 1493034401

 let timestamp = 1493036283;
 let momentstamp = moment.unix(timestamp)

   console.log('momentstamp', momentstamp.format("LLL")) //momentstamp 23 avril 2017 18:04
   console.log(moment(1493025800000).fromNow()) //il y a 2 heures
   console.log('momentstamp', momentstamp.format("LL")) //momentstamp 23 avril 2017

   console.log('momentstamp', momentstamp.format("DD MMM YY")) //momentstamp 23 avr. 17
   console.log('momentstamp', momentstamp.format("dddd, D MMM YY")) //momentstamp 23 avr. 17

   console.log('momentstamp', momentstamp.format("dddd, D MMM YY / h:mm"))  //momentstamp lundi, 24 avr. 17 / 8:18


   console.log('momentstamp', momentstamp.format("MMMM Do, YYYY / h:mm "))  //momentstamp lundi, 24 avr. 17 / 8:18

  </code></pre>
</div>


<div class="section">
  <h2>Redux - la base</h2>
  <li>En gros redux aide a maintenir des States</li>
  <li>et de la maniere que nos component sont fait avant redux, on fait quelque chose sur un component, et le parent fini le boulot par un props (ou le voir a l inverse), rendant les components peu reutilisable.</li>
  <li>Donc chaque component en ce moment depend d un autre, en passant l info par une fonction qui devient une props et demande donc a etre coupler avec un autre fichier. on peut faire mieux avec redux.</li>
  <li>donc avec un STORE, redux conserve ce qui est neccessaire, avec du simple JS, et des actions.</li>
  <li>redux peut etre utilise sans react, mais il vont bien ensemble, aussi, redux a un paquet de middleware pour tous les situations, et est bcp bcp simple que flux, lui de facebook.</li>

  <pre><code>
//exemple de setting redux

 let reduxState = {
  searchText: 'chien',
  showCompleted: false,
  todos: [
  {
    id: 123,
    text: 'promener le chien'
  }...
  ]
};

let action: {
  type: 'CHANGE_SEARCH_TEXT',
  searchText: 'quelquechose d autre'
}
  </code></pre>
</div>

<div class="section">
  <h2>Redux partII</h2>
  <li>refresh sur pur VS impure avec add function</li>
  <li>REDUX demande a travailler en PURE function sinon des trucs fonctionneront pas et donneront pas le resultat espere.</li>
  <ul>
      <li>donc les regles : </li>
      <li>avec les meme input, ca donne tjrs la meme chose</li>
      <li>pas de side-effects,change une variable exterieur</li>
      <li>eviter promises et async comme CB, ni meme se connecter a une database</li>
  </ul>


  <li>Voici un rappel</li>
  <pre><code>
    //pur function  si on met 2 et 2 ca donnera tjrs la meme chose et no side effects, change rien ailleurs.
    function add(a,b){
      return a + b
    }

    ///IMPURE
    //non pure , a pourrait changer.
    let a = 3
    function add( b){
      return a + b
    }
    //ou impure, ca change quelque chose a l exterieur. == side-effect
    let result
    function add( b){
      result = a + b
      return result;
    }
    //ou impure, on aura pas tjrs la meme reponse.
    function add(a,b){
      return a + b + new Date().getSeconds();
    }.


    ///PURE  COMMENT PASSER UN OBJ DANS UNE FN PURE.
    //pure, garde le meme obj. AVEC ES6
    function changePropPur(obj){
      return {
        ...obj,
        name: 'Dave'
      }
    }


    let res = changePropPur({
      name: 'Ben',
      age: 40
    })


    let startValue = {
      name: 'Ben',
      age: 40
    }
    console.log(changePropPur(startValue))///garde dave Object {name: "Dave", age: 40}
    console.log(res) ///garde dave Object {name: "Dave", age: 40}

  </code></pre>
</div>

<div class="section">
  <h2>Redux, part III , la decouverte et le reducer et du store</h2>
  <li>J'ai du faire un REQUIRE, import ne fonctionnait pas, il faut : import * as redux from 'redux' </li>
  <li>Pour creer un store, il faut un fn pure. la fonction reducer, une arrow function vide</li>
  <li>le store a donc besoin du reducer , et le reducer , a besoin du state qu il doit changer et l action qu il doit prendre</li>
  <li> le reducer, sa forme doit avoir : un objet par default pour le state et retourne un state a la fin. bravo </li>
  <li>donc le store est un simple object, avec endedans les states</li>
  <pre><code>
    import * as redux from 'redux'
    console.log('test de redux')

    //en es5 comme le name space, pour avoir un default. mais y a maintenant en es6, le default dans les arguments...
     <!-- let reducer = (state, action) => {
       state = state || { name: 'Anonymous' }
        return state
     }; //pas the BEST -->

     es6
     //es6
     let reducer = (state = {searchText :'', showCompleted: false, todos: [] }, action) => {
        return state
      };

      let stateDefault = {
        searchText : '',
        showCompleted: false,
        todos: []
      }
      let reducer = (state = stateDefault, action) => {
         console.log('Nouvelle action: ', action )  //permet de visualiser l entree des actions
         return state
       };


     let store = redux.createStore(reducer);

     let currentState = store.getState();
     console.log(currentState) // Object {searchText: "", showCompleted: false, todos: Array(0)} parfait !
     retourne le state de default.

  </code></pre>
</div>

<div class="section">
  <h2>Redux part IV , le store conserve, les actions changent</h2>
  <li>C'est avec les action qu on peut modifier les states, et les actions sont un simple object.</li>
  <li>la seule chose necessaire sur un obj action, est un type. celui ci represente le nom de l action.</li>
  <li>En regle generale, le nom, le type est en majuscule et utiliseles underscores</li>
  <li>ensuite la valeur que l 'on veut modifier'</li>
  <li>Ensuite, pour faire le changement, il s agit de DISPATCHER aux store : store.dispatch(et on y met l action voulue)</li>
  <li>Rien semble se produire, mais si on ajoute un checkeur avec console dans le dispatcher , on y voit l action s ajouter</li>
  <li>Pour que le dispatch change le data, il faut un switch statement.</li>
  <li>Dans celui, le case est le nom du type case 'CHANGE_NAME': et retourne un obj (ce qui etait (...state) et le nouveau :   name: action.name )  et il faut un default state aussi, et lui retourne le state.</li>
  <li>pour voir le changement il faut un nouvel store.getState()</li>
  <li>Ceci est la version lente , mais voila.</li>
  <li>pour raccourcir, on peut au lieu de creer un obj action, le mettre directement dans le dispatch.</li>
  <li>redu est le shortcut pour le reducer, c'est long a taper sinon. on peut combiner plusieur changement, voir dernier exemple.</li>
  <li>Donc voila, le reducer est une fonction pure, qui recoit des dispatch, et par un switch statement, prend le stateet lui modifie ses elements</li>
  <pre><code>
  //example d 'action

  let action = {
    type: 'CHANGE_NAME',
    name: 'Ben'
  }
store.dispatch(action)
//Nouvelle action:  Object {type: "@@redux/INIT"}  ///action par defaut
//Object {name: "Anonymous"} // l etat de l obj initial
//Nouvelle action:  Object {type: "CHANGE_NAME", name: "Ben"}  //injection de l action

mais a ce point ci rien ne change avant le switch statement dans le reducer:
switch (action.type) {  //le switch doit regarder le type de l action.

////maintenant avec es6, on prend le ...state et ajoute a celui ci et le default switch , retourne.

let reducer = (state = {name: 'Anonymous'}, action) => {
  console.log('Nouvelle action: ', action )  //permet de visualiser l entree des actions
  switch (action.type) {
   case 'CHANGE_NAME':
   return {
     ...state,     ///la raison, bien qu au debut ca fait pas de sens de ramener ce qu on a (rien) , au deuxieme dispacth
     name: action.name   //il faut tout ramener, sinon on repart a 0 tout le temps
   }
   default:
    return state
  }
};

//maintenant pour voir si ca fonctionne il faut un nouveau store.getState(),
 console.log('name devrait etre Ben', store.getState()) //name devrait etre Ben Object {name: "Ben"}

donc on a change une valeur, avec une fonction pure, sans avoir a faire un object.assign


 //pour prendre mois de temps:
 let action = {
   type: 'CHANGE_NAME',
   name: 'Ben'
 }
 store.dispatch(action);  //mais on verra rien pour l instant si pas de console dnas le reducer.

//DEVIENT
 store.dispatch({
   type: 'CHANGE_NAME',
   name: 'Ben'
 })



///EXEMPLE SUR DEUX ETATS///////////////EXEMPLE SUR DEUX ETATS////////////

let reducer = (state = stateDefault, action) => {
  console.log('Nouvelle action: ', action )  //permet de visualiser l entree des actions
  switch (action.type) {
   case 'CHANGE_TEXT':
   return {
     ...state,
     searchText: action.searchText
   }
   case 'CHANGE_BOOL':
   return {
     ...state,
     showCompleted: action.showCompleted
   }
   default:
    return state;
  }
};

let store = redux.createStore(reducer);
store.dispatch({
  type: 'CHANGE_TEXT',
  searchText: 'Change le text'
})
store.dispatch({
  type: 'CHANGE_BOOL',
  showCompleted: true
})

let currentState = store.getState();
//Object {searchText: "Change le text par un dispatch", showCompleted: true, todos: Array(0)}


///EXEMPLE SUR DEUX ETATS///////////////EXEMPLE SUR DEUX ETATS////////////
  </code></pre>
</div>

<div class="section">
  <h2>Redux, part V , subscribe </h2>
  <li>Pour remplacer les console de getState pour savoir si les choses on changes.</li>
  <li>a l exterieur plus besoin de mettre un paquet de console.log, pour tenir a jour les modifications</li>
  <li>Des qu'un changement se produit sur le state, on peut le veriifier , en regardant dans le subscribe, state.truc qu on veut savoir.</li>
  <li>subscribe par defaut retourne un fonction. Cette fonction permet de se unsubcriber . donc on peut l associer directement a unsubscrib : let unsubscribe = store.subscribe(()</li>
  <pre><code>

    let unsubscribe = store.subscribe(() => {
      let state = store.getState();
      console.log('name est', state.name )
    });
    store.dispatch({
      type: 'CHANGE_NAME',
      name: 'Ben'
    })
   unsubscribe();  //Benoit sortira pas. unsubcriber avant
    store.dispatch({
      type: 'CHANGE_NAME',
      name: 'Benoit'
    })

  </code></pre>
</div>

<div class="section">
  <h2>Redux dev-tools</h2>
  <li>l install est simple sur chrome</li>
  <li>Mais pour fonctionner, il faut que le dev tools voit un store. par defaut a ce point -ci il ne le voit pas.</li>
  <li>let store = redux.createStore(reducer) est l endroit ou on fait le lien en second argument.</li>

  <pre><code>

    let store = redux.createStore(reducer, redux.compose(
      window.devToolsExtension ? window.devToolsExtension() : f => f
    ));

  </code></pre>
</div>

<div class="section">
  <h2>Redux part VI, dealer avec les arr d'obj</h2>
  <li>Il est important de comprendre pourquoi, on ...state ou ...state.hobbies, bien qu au debut, il n 'a rien a ramener, il faut comprendre que ce loop va se faire plusieurs fois, a chaque dispatch, donc ...state, ou autre, est la pour ne pas perdre ce qui etait la avant, avec le dispatch , on ne veut pas repartir a zero, mais c'est une progression plutot.</li>
  <li>Il est une bonne idee avec les arr, de se faire un systeme d'Id. plus facile se retrouver par la suite.</li>
  <pre><code>
 ES6 avec l extentiation ...

 let stateDefault = {
   name: 'Anonymous',
   hobbies: []
 }

let nextHobbyId = 1; ajoute un systeme d Id

let reducer = (state = stateDefault, action) => {

  switch (action.type) {
   case 'CHANGE_NAME':
   return {
     ...state,                       //pour le deuxieme tours, on doit ramener tout
     name: action.name
   }
   case 'ADD_HOBBY':               //pour l arr.
   return {                        /// on retourne tout avant
     ...state,
     hobbies: [                   ///ensuite pour l arr hobbies
       ...state.hobbies,           /// on retourne tout avant (meme si rien, en partant) , sinon on overwrite
       {
         id: nextHobbyId++,       //ajouter un Id
         hobby: action.hobby     //ensuite lobj qu on veut dans l arr
       }
     ]
   }
   default:
    return state;
  }
};
//Donne
///Object {id: 1, hobby: "Courrir"} Object {id: 2, hobby: "Sauter a la corde"}
  </code></pre>
</div>


<div class="section">
  <h2>Redux part VIII, REMOVE STUFF</h2>
  <li>Maintenant qu/on sait ajouter, comment retirer...</li>
  <li>D'abord dasn le dispatch, on doit avoir ce que l'on veut pu, qu on veut deleter, pas besoin de rentrer tous les trucs, juste le id est ok.</li>
  <li>ensuite dans le reducer, on doit RESTER PUR. map filter, sort, sont du bon stock ! Donc filter est le best pour ca.</li>
  <li>On fait un retour sur tout ce qui n'est pas ce que l on veut sur le dispatch, et that it.</li>
  <li>Comme on peut voir ici le reducer s'en vient long, on va diviser ca..</li>
  <pre><code>

 le dispatch
 store.dispatch({
   type: 'REMOVE_HOBBY',
   id: 2
 })
 store.dispatch({
   type: 'REMOVE_MOVIE',
   id: 1
 })

sur le reducer :
let reducer = (state = stateDefault, action) => {

  switch (action.type) {
   case 'CHANGE_NAME':
   return {
     ...state,     //pour le deuxieme tours, on doit ramener tout
     name: action.name
   }
   case 'ADD_HOBBY':        //pour l arr.
   return {                 /// on retourne tout avant
     ...state,
     hobbies: [            ///ensuite pour l arr hobbies
       ...state.hobbies,     /// on retourne tout avant (meme si rien, en partant) , sinon on overwrite
       {
         id: nextHobbyId++,   //ajouter un Id
         hobby: action.hobby     //ensuite lobj qu on veut dans l arr
       }
     ]
   }
   ///////   ///////   ///////   ///////  ICI  ///////   ///////   ///////   ///////
   case 'REMOVE_HOBBY':    // RETIRER de l arr, ce qu'on ne veut pas
   return {               /// on retourne tout avant
     ...state,
     hobbies: state.hobbies.filter((hobby) => {
       return hobby.id !== action.id          // on retourne tout ce qui n'a pas id: 2 finalement
     })
   }
  ///////   ///////   ///////   ///////  ICI  ///////   ///////   ///////   ///////
   case 'ADD_MOVIE':  //pour l arr.
   return {           /// on retourne tout avant
     ...state,
     movies: [           ///ensuite pour l arr hobbies
       ...state.movies,     /// on retourne tout avant (meme si rien, en partant) , sinon on overwrite
       {
         id: nextMovieId++,   //ajouter un Id
         title: action.title,
         genre: action.genre     //ensuite lobj qu on veut dans l arr
       }
     ]
   }
      ///////   ///////   ///////   ///////  ICI  ///////   ///////   ///////   ///////
   case 'REMOVE_MOVIE':    // RETIRER de l arr, ce qu'on ne veut pas
   return {               /// on retourne tout avant
     ...state,
     movies: state.movies.filter((movie) => {
       return movie.id !== action.id          // on retourne tout ce qui n'a pas id: 2 finalement
     })
   }
      ///////   ///////   ///////   ///////  ICI  ///////   ///////   ///////   ///////
   default:
    return state;
  }
};
  </code></pre>
</div>

<div class="section">
  <h2>Redux, part IX , plusieurs reducer , pour mieux s'y retrouver.</h2>
  <li>Nous avons ici des names, hobbies et movies, il serait p-e temps de faire des reducers plus specifiques.</li>
  <li>Il est donc possible de diviser les taches, certes , ce sans meme s'en remettre a la magie noire, ou priere celestres.</li>
  <li>let reducer = redux.combineReducers( { name: nameReducer}) </li>
  <li>Ici maintenant que name n'est plus un object, mais juste un string , on change de Anonymous a Beb a Benoit, tous des strings</li>
  <li>Dans le cas des arrays, on retourne un array, et celui ci est simplement sur state et NON pas sur state.movies.. </li>
  <li>donc ici on a un meilleur patern de boulot.</li>
  <pre><code>
     //NAME
    let nameReducer = (state = 'Anonymous', action) => {
      switch (action.type) {
       case 'CHANGE_NAME':
       return  action.name          /// on ne retourne pas d object.
       default:
       return state;
     }
    }
    //HOOBIES
    let hobbiesReducer = (state = [], action) => {
      switch (action.type) {
       case 'ADD_HOBBY':
       return [                       ///ensuite pour l arr hobbies
           ...state,               /// on retourne juste state
           {
             id: nextHobbyId++,   //ajouter un Id
             hobby: action.hobby     //ensuite lobj qu on veut dans l arr
           }
         ];
       case 'REMOVE_HOBBY':                        // RETIRER de l arr, ce qu'on ne veut pas
       return state.filter((hobby) => {             // l arr est sur state
             return hobby.id !== action.id          // on retourne tout ce qui n'a pas id: 2 finalement
         })
       default:
       return state;
     }
    }

  //MOVIES
  let moviesReducer = (state = [], action) => {
    switch (action.type) {
     case 'ADD_MOVIE':
     return [
         ...state,                         /// on retourne juste state
         {
           id: nextMovieId++,              //ajouter un Id
           title: action.title,
           genre: action.genre             //ensuite lobj qu on va dans l arr
         }
       ];
     case 'REMOVE_MOVIE':                        // RETIRER de l arr, ce qu'on ne veut pas
     return state.filter((movie) => {             // l arr est sur state
           return movie.id !== action.id          // on retourne tout ce qui n'a pas id: 2 finalement
       })
     default:
     return state;
   }
  }

  //quand plusieurs reducer
  let reducer = redux.combineReducers({
    name: nameReducer,
    hobbies: hobbiesReducer,
    movies: moviesReducer
  })

  let store = redux.createStore(reducer, redux.compose(
    window.devToolsExtension ? window.devToolsExtension() : f => f
  ));


  let unsubscribe = store.subscribe(() => {
    let state = store.getState();
   console.log('Du nouveau', store.getState())
  });

  ... le reste sont les dispatch.

  </code></pre>
</div>


<div class="section">
  <h2>Redux, part X , action generators</h2>
  <li>Les generator d actyion, sont de simple fonction, qui retourne un object, le meme object qui va dans les dispatch</li>
  <li>Le but est de pas se retrouver avec 3000 long dispatch dans une page.</li>
  <li>Cela raccourcie de loin le processus, et dans des dispatch plus complex, fera moins d erreur.</li>
  <li>Aussi plus simple a appeler sur des truc async.</li>
  <pre><code>
  //  un generator , ne prend pas le type en argument, seulement la valeur
    let changeName = (name) => {
      return {
        type: 'CHANGE_NAME',
        name: name   //en ES6 , si la key et la value est la meme, on peut juste mettre name voir ligne 1143
         }

  // comparer a un dispatch
   store.dispatch({
     type: 'CHANGE_NAME',
     name: 'Ben'
   })

// ES6
let changeName = (name) => {
  return {
    type: 'CHANGE_NAME',
    name
  }

et le dispatch devient :

store.dispatch(changeName('Buck')); ///bcp plus simple

et

let addHobby = (hobby) => {
  return {
    type: 'ADD_HOBBY',
    hobby
  }
};
 store.dispatch(addHobby('Sauter a la corde'))


//REMOVE
let removeHobby = (id) => {
  return {
    type: 'REMOVE_HOBBY',
    id
  }
};
 store.dispatch(removeHobby(2));

//plusieurs arguments
let addMovie = (title, genre) => {
  return {
    type: 'ADD_MOVIE',
    title,
    genre
  }
};
store.dispatch(addMovie('Run lola Run','thriller'))

  </code></pre>
</div>

<div class="section">
  <h2>Redux part XI, async generators</h2>
  <li>La methode est differente, on y va dans l exemple avec un site ipinfo.io qui donne la longitude et lattitude. </li>
  <li>Avec ces donnees, on peut faire une recherche sur google map en ajoutant dans le q=? le query les donnees retrouve</li>
  <li>Le reducer, state sera un objet, on a seulement besoin de deux etats, avant et rechercher le data </li>
  <li>puisque deux etats , deux dispatch sont necessaires, on doit les combiner dans une function.</li>
  <li>je l ai fait en jquery et axios, les deux fonctionnent</li>
  <li>on doit ajouter le reducer a notre redux.combineReducers({</li>
  <li>derniere etape , le subscribe... voir code.</li>
  <pre><code>

    let mapReducer = (state = {isFetching: false, url: undefined}, action) => {
      switch (action.type) {
       case 'START_LOCATION_FETCH' :
       return {
         isFetching: true,
         url: undefined
       }
       case 'COMPLETE_LOCATION_FETCH' :
       return {
         isFetching: false,
         url: action.url
       }
       default:
        return state;
      }
    };

   //on part la le fetch,
    let startLocationFetch = () => {
      return {
        type: 'START_LOCATION_FETCH',
      }
    };
  ///on a l url
    let completeLocationFetch = (url) => {
      return {
        type: 'COMPLETE_LOCATION_FETCH',
        url
      }
    };

puisque deux etats , deux dispatch sont necessaires, on doit les combiner dans une function.

let fetchLocation = () => {
  store.dispatch(startLocationFetch())  //ouvre le query .. mais fait rien ..
    $.getJSON('https://ipinfo.io', function(data){  ///va chercher le data
    let loc = data.loc;                             //log et lat
    let baseUrl = 'http://maps.google.com?q=';     //fait la moitier de l url
    store.dispatch(completeLocationFetch(baseUrl + loc))  ///lance le deuxieme dispatch, avec url complet
  })
}

//passer 2 dispatch pour du ASYNC
// let fetchLocation = () => {
//   store.dispatch(startLocationFetch())  //ouvre le query .. mais fait rien ..
//     axios.get('https://ipinfo.io').then(function (res) {
//     let loc = res.data.loc;                             //log et lat
//     let baseUrl = 'http://maps.google.com?q=';     //fait la moitier de l url
//     store.dispatch(completeLocationFetch(baseUrl + loc))  ///lance le deuxieme dispatch, avec url complet
//   })
// }


//quand plusieurs reducer
let reducer = redux.combineReducers({
  name: nameReducer,
  hobbies: hobbiesReducer,
  movies: moviesReducer,
  map: mapReducer
})

et pour voir le resultat dans le subscribe

voir le code dans redux-example


  </code></pre>
</div>

<div class="section">
  <h2>Redux part XII, la separation des fichiers</h2>
  <li>un rep actions, reducers, et store... aka configure</li>
  <li>un Add-on de redux a installer pour nous aider, specifiquement pour fetch location qui mele le reducer avec action dans son code : npm install --save-dev redux-thunk </li>
  <li>thunk est un middleware, qu on doit ajouter a la configuration , dans la func configure dans le configureStore.js</li>
  <li>on doit le requirer let thunk = require('redux thunk').default</li>
  <li>Tout nos reducer sont des object, tout sauf un : fetchLocation qui est une function</li>
  <li>thunk permet de passer une function, en enelevant le besoint d avoir un store dans la function et faisant un return fn .. complexe .. </li>
  <li>maintenant au lieu de faire le dispatch dasn la function, avec le middleware , redux est capable de dispatcher les func. donc on l appelle comme les autres obj, avec  store.dispatch(fetchLocation());</li>
  <li>C'est important dans la mesure ou tous les dispatch pour du async, doivent se faire de cette maniere...</li>
  <li>L autre option est de ramener dans l app ces actions la (eux avec des func), a cette endroit tout fontionne comme avant.</li>
  <li>Fin de l exemple redux, on retourne au todo pour integrer redux</li>
  <pre><code>
/// avec thnuk
export let fetchLocation = () => {
  return (dispatch, getState) => {
    dispatch(startLocationFetch())  //ouvre le query .. mais fait rien ..
      $.getJSON('https://ipinfo.io', function(data){  ///va chercher le data
      let loc = data.loc;                             //log et lat
      let baseUrl = 'http://maps.google.com?q=';     //fait la moitier de l url
     dispatch(completeLocationFetch(baseUrl + loc))  ///lance le deuxieme dispatch, avec url complet
    })
  }
}
//la config.
let thunk = require('redux-thunk').default
let store = redux.createStore(reducer, redux.compose(
  redux.applyMiddleware(thunk),
  window.devToolsExtension ? window.devToolsExtension() : f => f
));

et dasn l app
 store.dispatch(fetchLocation());

VS avant


// let fetchLocation = () => {
//   store.dispatch(startLocationFetch())  //ouvre le query .. mais fait rien ..
//     $.getJSON('https://ipinfo.io', function(data){  ///va chercher le data
//     let loc = data.loc;                             //log et lat
//     let baseUrl = 'http://maps.google.com?q=';     //fait la moitier de l url
//     store.dispatch(completeLocationFetch(baseUrl + loc))  ///lance le deuxieme dispatch, avec url complet
//   })
// }
fetchLocation()

  </code></pre>
</div>




</div> <!--fin-->

</body>
</html>
